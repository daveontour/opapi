package cmd

import (
	"bytes"
	"context"
	"fmt"
	"log"
	"math/rand"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	globals "github.com/daveontour/opapi/opapi/globals"
	"github.com/daveontour/opapi/opapi/models"
	"github.com/daveontour/opapi/opapi/timeservice"

	amqp "github.com/rabbitmq/amqp091-go"

	"github.com/go-co-op/gocron"
	"github.com/spf13/viper"
)

var perfTestFlights []string

func demo(numFlightsSt string, minCustomPropertiesSt string, append string) {
	nf, _ := strconv.Atoi(numFlightsSt)
	minf, _ := strconv.Atoi(minCustomPropertiesSt)
	b1, _ := strconv.ParseBool(append)

	SendFlightMessages(nf, minf, b1, "HTTP", false)
}

func perfTest(numFlightsSt string, minCustomPropertiesSt string, continuousUpdateModeSt string) {
	nf, _ := strconv.Atoi(numFlightsSt)
	minf, _ := strconv.Atoi(minCustomPropertiesSt)
	continuousUpdate, _ := strconv.ParseBool(continuousUpdateModeSt)

	SendFlightMessages(nf, minf, false, "RMQ", continuousUpdate)
}

const standslottemplate = `<StandSlots>
<StandSlot>
  <Value propertyName="StartTime">%s</Value>
  <Value propertyName="EndTime">%s</Value>
  <Stand>
    <Value propertyName="Name">%s</Value>
    <Value propertyName="ExternalName">%s</Value>
    <Area>
      <Value propertyName="Name">%s</Value>
    </Area>
  </Stand>
</StandSlot>
</StandSlots>`

const checkinslotstemplate = `
<CheckInSlots>
<CheckInSlot>
  <Value propertyName="StartTime">%[1]s</Value>
  <Value propertyName="EndTime">%[2]s</Value>
  <Value propertyName="Category">Economy</Value>
  <CheckIn>
    <Value propertyName="Name">%[3]s%[4]d</Value>
    <Value propertyName="ExternalName">%[3]s%[4]d</Value>
    <Area>
      <Value propertyName="Name">%[3]s</Value>
    </Area>
  </CheckIn>
</CheckInSlot>
<CheckInSlot>
  <Value propertyName="StartTime">%[1]s</Value>
  <Value propertyName="EndTime">%[2]s</Value>
  <Value propertyName="Category">Economy</Value>
  <CheckIn>
    <Value propertyName="Name">%[3]s%[5]d</Value>
    <Value propertyName="ExternalName">%[3]s%[5]d</Value>
    <Area>
      <Value propertyName="Name">%[3]s</Value>
    </Area>
  </CheckIn>
</CheckInSlot>
<CheckInSlot>
<Value propertyName="StartTime">%[1]s</Value>
<Value propertyName="EndTime">%[2]s</Value>
  <Value propertyName="Category">Economy</Value>
  <CheckIn>
    <Value propertyName="Name">%[3]s%[6]d</Value>
    <Value propertyName="ExternalName">%[3]s%[6]d</Value>
    <Area>
      <Value propertyName="Name">%[3]s</Value>
    </Area>
  </CheckIn>
</CheckInSlot>
<CheckInSlot>
<Value propertyName="StartTime">%[1]s</Value>
<Value propertyName="EndTime">%[2]s</Value>
  <Value propertyName="Category">Economy</Value>
  <CheckIn>
    <Value propertyName="Name">%[3]s%[7]d</Value>
    <Value propertyName="ExternalName">%[3]s%[7]d</Value>
    <Area>
      <Value propertyName="Name">%[3]s</Value>
    </Area>
  </CheckIn>
</CheckInSlot>
</CheckInSlots>
`
const gateslotstemplate = `
<GateSlots>
<GateSlot>
  <Value propertyName="StartTime">%s</Value>
  <Value propertyName="EndTime">%s</Value>
  <Value propertyName="Category">departure</Value>
  <Gate>
    <Value propertyName="Name">%s</Value>
    <Value propertyName="ExternalName">%s</Value>
    <Area>
      <Value propertyName="Name">%s</Value>
    </Area>
  </Gate>
</GateSlot>
</GateSlots>
`

const carouselslotstemplate = `
<CarouselSlots>
<CarouselSlot>
  <Value propertyName="StartTime">%s</Value>
  <Value propertyName="EndTime">%s</Value>
  <Value propertyName="Category" />
  <Carousel>
    <Value propertyName="Name">%s</Value>
    <Value propertyName="ExternalName">%s</Value>
    <Area>
      <Value propertyName="Name">%s</Value>
    </Area>
  </Carousel>
</CarouselSlot>
</CarouselSlots>
`

type AutoGenerated struct {
	TestConfig struct {
		Repository   models.Repository `json:"Repository"`
		CheckinAreas []struct {
			Area   string `json:"Area"`
			Number int    `json:"Number"`
		} `json:"CheckinAreas"`
		GateAreas []struct {
			Area   string `json:"Area"`
			Number int    `json:"Number"`
		} `json:"GateAreas"`
		StandAreas []struct {
			Area   string `json:"Area"`
			Number int    `json:"Number"`
		} `json:"StandAreas"`
		CarouselAreas []struct {
			Area   string `json:"Area"`
			Number int    `json:"Number"`
		} `json:"CarouselAreas"`
		ChuteAreas []struct {
			Area   string `json:"Area"`
			Number int    `json:"Number"`
		} `json:"ChuteAreas"`
		Airlines []string `json:"Airlines"`
		Routes   []string `json:"Routes"`
	} `json:"TestConfig"`
}

var testConfig AutoGenerated

func SendFlightMessages(nf int, minf int, appendFlag bool, transport string, continuousUpdate bool) (minDate, maxDate time.Time) {

	exe, err0 := os.Executable()
	if err0 != nil {
		panic(err0)
	}
	exPath := filepath.Dir(exe)
	testViper := viper.New()

	testViper.SetConfigName("test")        // name of config file (without extension)
	testViper.SetConfigType("json")        // REQUIRED if the config file does not have the extension in the name
	testViper.AddConfigPath("./testfiles") // optionally look for config in the working directory
	testViper.AddConfigPath(exPath)
	if err := testViper.ReadInConfig(); err != nil {
		globals.Logger.Fatal("Could Not Read test.json config file")
	}

	if err := testViper.Unmarshal(&testConfig); err != nil {
		fmt.Println("Error reading test config file")
		return
	}
	t := time.Now()

	fileContent, err := os.ReadFile("testfiles/arrival.template.xml")
	if err != nil {
		log.Fatal(err)
	}
	arrFlightUpdateBody := string(fileContent)

	fileContent, err = os.ReadFile("testfiles/departure.template.xml")
	if err != nil {
		log.Fatal(err)
	}
	depFlightUpdateBody := string(fileContent)

	minDate = time.Date(2040, 12, 30, 0, 0, 0, 0, timeservice.Loc)
	maxDate = time.Date(2000, 12, 30, 0, 0, 0, 0, timeservice.Loc)

	var sb strings.Builder

	for i := 113; i < minf; i++ {
		sb.WriteString("<Value propertyName=\"" + "Custom_Field_Name_" + strconv.Itoa(i) + "\">" + "Custom_Field_Value_" + strconv.Itoa(i) + "</Value>\n")
	}

	additionalValues := sb.String()

	requestURL := "http://" + globals.ConfigViper.GetString("ServiceIPport") + "/demoMessageUpdate"

	if appendFlag {
		requestURL = "http://" + globals.ConfigViper.GetString("ServiceIPport") + "/demoMessageAppend"
	}

	for i := 0; i < nf; i = i + 2 {

		al := testConfig.TestConfig.Airlines[i%len(testConfig.TestConfig.Airlines)]
		route := testConfig.TestConfig.Routes[i%len(testConfig.TestConfig.Routes)]
		arrivalFlightNumber := 1 + i
		departureFlightNumber := arrivalFlightNumber + 1

		departureSTO := time.Date(t.Year(), t.Month(), t.Day(), 0, 0, 0, 0, t.Location())
		departureSTO = departureSTO.Add(time.Minute * time.Duration(i))
		if departureSTO.Before(minDate) {
			minDate = departureSTO
		}
		if departureSTO.After(maxDate) {
			maxDate = departureSTO
		}

		checkInOpenTime := departureSTO.Add(time.Minute * time.Duration(-1*180))
		checkInOpenTimeString := checkInOpenTime.Format(timeservice.Layout)
		checkInCloseTime := checkInOpenTime.Add(time.Minute * time.Duration(135))
		checkInCloseTimeString := checkInCloseTime.Format(timeservice.Layout)

		departureGateOpenTime := departureSTO.Add(time.Minute * time.Duration(-1*60))
		departureGateOpenTimeString := departureGateOpenTime.Format(timeservice.Layout)

		arrivalSTO := departureSTO.Add(time.Minute * time.Duration(-1*125))
		if arrivalSTO.Before(minDate) {
			minDate = arrivalSTO
		}
		if arrivalSTO.After(maxDate) {
			maxDate = arrivalSTO
		}
		arrivalSTOString := arrivalSTO.Format(timeservice.Layout)

		arrivalGateCloseTime := arrivalSTO.Add(time.Minute * time.Duration(30))
		arrGateCloseTimeString := arrivalGateCloseTime.Format(timeservice.Layout)

		arrivalCarouselOpenTime := arrivalSTO.Add(time.Minute * time.Duration(15))
		// carouselst := carouselopen.Format(timeservice.Layout)

		arrivalCarouselCloseTime := arrivalCarouselOpenTime.Add(time.Minute * time.Duration(60))
		arrivalCarouselCloseTimeString := arrivalCarouselCloseTime.Format(timeservice.Layout)

		standOpenTime := arrivalSTO.Add(time.Minute * time.Duration(-15))
		standOpenTimeString := standOpenTime.Format(timeservice.Layout)

		standCloseTime := departureSTO.Add(time.Minute * time.Duration(15))
		standCloseTimeString := standCloseTime.Format(timeservice.Layout)

		gateArea := testConfig.TestConfig.GateAreas[i%len(testConfig.TestConfig.GateAreas)]
		standArea := testConfig.TestConfig.StandAreas[i%len(testConfig.TestConfig.StandAreas)]
		// chuteArea := config.TestConfig.ChuteAreas[i%len(config.TestConfig.ChuteAreas)]
		carouselArea := testConfig.TestConfig.CarouselAreas[i%len(testConfig.TestConfig.CarouselAreas)]
		checkinArea := testConfig.TestConfig.CheckinAreas[i%len(testConfig.TestConfig.CheckinAreas)]

		gateNum := rand.Intn(gateArea.Number) + 1
		standNum := rand.Intn(standArea.Number) + 1
		// chuteNum := rand.Intn(chuteArea.Number)+1
		carouselNum := rand.Intn(carouselArea.Number) + 1
		checkinNum := rand.Intn(checkinArea.Number-4) + 1

		arrivalSDOString := arrivalSTO.Format("2006-01-02")
		departureSTOString := departureSTO.Format(timeservice.Layout)
		departureSDOString := departureSTO.Format("2006-01-02")
		registration := fmt.Sprintf("VH-%d", i)

		checkinslot := fmt.Sprintf(checkinslotstemplate,
			checkInOpenTimeString,
			checkInCloseTimeString,
			checkinArea.Area,
			checkinNum,
			checkinNum+1,
			checkinNum+2,
			checkinNum+3)

		standslot := fmt.Sprintf(standslottemplate,
			standOpenTimeString,
			standCloseTimeString,
			fmt.Sprintf("%s%d", standArea.Area, standNum),
			fmt.Sprintf("%s%d", standArea.Area, standNum),
			standArea.Area)

		gateDepartureSlot := fmt.Sprintf(gateslotstemplate,
			departureGateOpenTimeString,
			departureSTOString,
			fmt.Sprintf("%s%d", gateArea.Area, gateNum),
			fmt.Sprintf("%s%d", gateArea.Area, gateNum),
			standArea.Area)

		gateArrivalSlot := fmt.Sprintf(gateslotstemplate,
			arrivalSTOString,
			arrGateCloseTimeString,
			fmt.Sprintf("%s%d", gateArea.Area, gateNum),
			fmt.Sprintf("%s%d", gateArea.Area, gateNum),
			standArea.Area)

		carouselSlot := fmt.Sprintf(carouselslotstemplate,
			arrivalSTOString,
			arrivalCarouselCloseTimeString,
			fmt.Sprintf("%s%d", carouselArea.Area, carouselNum),
			fmt.Sprintf("%s%d", gateArea.Area, carouselNum),
			carouselArea.Area)

		depNumStr := strconv.Itoa(departureFlightNumber)
		arrNumStr := strconv.Itoa(arrivalFlightNumber)

		for len(depNumStr) < 4 {
			depNumStr = "0" + depNumStr
		}
		for len(arrNumStr) < 4 {
			arrNumStr = "0" + arrNumStr
		}

		depmsg := fmt.Sprintf(depFlightUpdateBody,
			al,
			depNumStr,
			departureSDOString,
			testConfig.TestConfig.Repository.AMSAirport,
			departureSTOString,
			al,
			arrNumStr,
			arrivalSDOString,
			testConfig.TestConfig.Repository.AMSAirport,
			arrivalSTOString,
			324174+i,
			registration,
			route,
			234174+i,
			additionalValues,
			standslot,
			gateDepartureSlot,
			checkinslot)

		arrmsg := fmt.Sprintf(arrFlightUpdateBody,
			al,
			arrNumStr,
			arrivalSDOString,
			testConfig.TestConfig.Repository.AMSAirport,
			arrivalSTOString,
			al,
			depNumStr,
			departureSDOString,
			testConfig.TestConfig.Repository.AMSAirport,
			departureSTOString,
			234174+i,
			registration,
			route,
			324174+i,
			additionalValues,
			standslot,
			gateArrivalSlot,
			carouselSlot)

		if transport == "HTTP" {
			body := []byte(arrmsg)
			bodyReader := bytes.NewReader(body)

			req, _ := http.NewRequest(http.MethodPost, requestURL, bodyReader)

			client := http.Client{
				Timeout: 5 * time.Second,
			}

			_, err := client.Do(req)
			if err != nil {
				fmt.Printf("Unable to send data to  %s\n", requestURL)
				os.Exit(1)
			}
			fmt.Print("A")

			body = []byte(depmsg)
			bodyReader = bytes.NewReader(body)
			req, _ = http.NewRequest(http.MethodPost, requestURL, bodyReader)
			_, err = client.Do(req)
			if err != nil {
				fmt.Printf("Unable to send data to  %s\n", requestURL)
				os.Exit(1)
			}
			fmt.Print("D")

			if i%100 == 0 && i != 0 {
				fmt.Printf("[%d]\n", i)
			}
		}

		if transport == "RMQ" {

			publishtopic(arrmsg)
			fmt.Print("A")
			publishtopic(depmsg)
			fmt.Print("D")
			if i%100 == 0 && i != 0 {
				fmt.Printf("[%d]\n", i)
			}

			if continuousUpdate {
				perfTestFlights = append(perfTestFlights, arrmsg)
				perfTestFlights = append(perfTestFlights, depmsg)
			}
		}
	}

	if nf%100 != 0 {
		fmt.Printf("[%d]\n", nf)
	}

	if continuousUpdate {
		continuousUpdates()
	}
	return
}

func parse(in string) {

	list := strings.Split(in, " ")
	var realList []string

	for _, x := range list {
		if x != "" {
			realList = append(realList, x)
		}
	}

	fmt.Println(strings.ReplaceAll(realList[4], ",", ""))
}
func failOnError(err error, msg string) {
	if err != nil {
		log.Panicf("%s: %s", msg, err)
	}
}

func continuousUpdates() {
	fmt.Println("\nScheduling continuous updates")
	s := gocron.NewScheduler(time.Local)
	s.Every(20).Second().Do(func() {
		updateJob()
	})
	s.StartBlocking()
}

func updateJob() {

	min := 5
	max := 20
	flightsToUpdate := rand.Intn(max-min+1) + min

	fmt.Printf("Simulating updates of %v flight", flightsToUpdate)
	for i := 0; i < flightsToUpdate; i++ {
		flightIdx := rand.Intn(len(perfTestFlights))
		publishtopic(perfTestFlights[flightIdx])
		fmt.Printf("[%v] Updating Flight \n", time.Now())
	}

}
func publishtopic(message string) {
	conn, err := amqp.Dial("amqp://amsauh:amsauh@localhost:5672/amsauh")
	failOnError(err, "Failed to connect to RabbitMQ")
	defer conn.Close()

	ch, err := conn.Channel()
	failOnError(err, "Failed to open a channel")
	defer ch.Close()

	err = ch.ExchangeDeclare(
		"Test",  // name
		"topic", // type
		true,    // durable
		false,   // auto-deleted
		false,   // internal
		false,   // no-wait
		nil,     // arguments
	)
	failOnError(err, "Failed to declare an exchange")

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	err = ch.PublishWithContext(ctx,
		"Test",        // exchange
		"AMSX.Notify", // routing key
		false,         // mandatory
		false,         // immediate
		amqp.Publishing{
			ContentType: "text/plain",
			Body:        []byte(message),
		})
	failOnError(err, "Failed to publish a message")
}
